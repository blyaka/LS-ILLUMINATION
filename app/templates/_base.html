{% load static %}
{% load categories_tags %}


<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  {% block title %}
  <title>LS-ILLIMINATOIN</title>
  {% endblock title %}


  <link rel="stylesheet" href="{% static 'css/base.css' %}">


  {% block styles %}

  {% endblock styles %}

</head>

<body class="{% if request.resolver_match.url_name == 'home' %}is-home{% endif %}">

  <canvas id="balls-bg" class="balls-bg" aria-hidden="true"></canvas>
1

  <script>
  (() => {
    const cv = document.getElementById('balls-bg');
    if (!cv) return;
    const ctx = cv.getContext('2d', { alpha: true });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const CFG = {
      count: 5,
      speedMin: 22,
      speedMax: 48,
      margin: 120,
      avoidPad: 32,
      colors: ['#5ecbff', '#fa2af6', '#8b5cf6'],
      radii: [180, 220, 260, 160, 200],
      jitter: 0.08,
      defaultSpawn: 5,

      plateauAlpha: 0.32,
      innerStop: 0.14,
      edgeStop: 0.14,
      blurPx: 1.4,
      blend: 'screen'
    };

    const state = {
      worldW: 0, worldH: 0,
      viewW: 0, viewH: 0,
      scrollY: 0,
      rects: [],       // no-fly
      spawns: [],      // { id, rect:{x,y,w,h}, count }
      blobs: [],
    };

    // --- utils ---
    const rand=(a,b)=>a+Math.random()*(b-a);
    const pick=a=>a[Math.floor(Math.random()*a.length)];
    const clamp=(v,min,max)=>Math.max(min, Math.min(max, v));
    const getSX=()=>window.pageXOffset || document.documentElement.scrollLeft || 0;
    const getSY=()=>window.pageYOffset || document.documentElement.scrollTop  || 0;
    const uid=(()=>{let i=0;return()=>`sp${++i}`;})();

    // --- sizing ---
    function resize() {
      const de = document.documentElement, db = document.body;
      state.viewW = window.innerWidth;
      state.viewH = window.innerHeight;
      state.worldW = de.clientWidth;
      // базовый мир = текущий scrollHeight
      state.worldH = Math.max(de.scrollHeight, db?.scrollHeight || 0, de.clientHeight);

      const w = Math.round(state.viewW * DPR);
      const h = Math.round(state.viewH * DPR);
      if (cv.width !== w || cv.height !== h) {
        cv.width = w; cv.height = h;
        cv.style.width = state.viewW + 'px';
        cv.style.height = state.viewH + 'px';
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
    }

    function rectOfEl(el, pad=0){
      const r = el.getBoundingClientRect();
      const sx = getSX(), sy = getSY();
      return { x: Math.max(0, r.left + sx) - pad,
              y: Math.max(0, r.top  + sy) - pad,
              w: r.width + pad*2,
              h: r.height + pad*2 };
    }

    function collect(){
      // no-fly: поддерживаем и data-no-fly на всякий
      const nf = new Set([
        ...document.querySelectorAll('[data-nofly],[data-no-fly]'),
        ...API.extraNoFly.flatMap(s => Array.from(document.querySelectorAll(s)))
      ]);
      state.rects = Array.from(nf).map(el => rectOfEl(el, CFG.avoidPad));

      // spawn: поддерживаем и data-spwn
      const spNodes = Array.from(document.querySelectorAll('[data-spawn],[data-spwn]'));
      state.spawns = spNodes.map(el => {
        if (!el.__spawnId) el.__spawnId = uid();
        const raw = el.getAttribute('data-spawn') ?? el.getAttribute('data-spwn');
        const count = parseInt(raw ?? CFG.defaultSpawn, 10) || CFG.defaultSpawn;
        return { id: el.__spawnId, rect: rectOfEl(el, 0), count };
      });

      // расширяем мир до низа всех спавн-зон, чтобы апдейт не «упирал» их в границу
      if (state.spawns.length){
        const maxR = Math.max(...CFG.radii);
        const bottom = Math.max(...state.spawns.map(s => s.rect.y + s.rect.h));
        state.worldH = Math.max(state.worldH, bottom + CFG.margin + maxR + 1);
      }
    }

    // --- collision ---
    function circleRectOverlap(b, R, rc){
      const cx = clamp(b.x, rc.x, rc.x + rc.w);
      const cy = clamp(b.y, rc.y, rc.y + rc.h);
      const dx = b.x - cx, dy = b.y - cy;
      const dist2 = dx*dx + dy*dy;
      return dist2 < R*R ? { hit:true, dx, dy, dist: Math.sqrt(dist2) } : { hit:false };
    }
    function overlapsNoFly(x,y,rad){
      for (const rc of state.rects){
        if (y + rad < rc.y || y - rad > rc.y + rc.h) continue;
        if (circleRectOverlap({x,y}, rad, rc).hit) return true;
      }
      return false;
    }
    function steerAway(b, info){
      const nx = info.dist>0 ? info.dx/info.dist : (Math.random()*2-1);
      const ny = info.dist>0 ? info.dy/info.dist : (Math.random()*2-1);
      const push = (b.r - info.dist) + 1;
      b.x += nx * push; b.y += ny * push;
      const vDotN = b.vx*nx + b.vy*ny;
      b.vx -= 2*vDotN*nx; b.vy -= 2*vDotN*ny;
      b.vx *= 0.96; b.vy *= 0.96;
    }

    // --- spawn ---
    function placeInsideRect(r, rad){
      // x: внутри секции с учётом margin, y: строго внутри секции БЕЗ клампа к worldH
      const M = CFG.margin;
      const x = rand(Math.max(M+rad, r.x+rad), Math.min(state.worldW-M-rad, r.x + r.w - rad));
      const y = rand(r.y+rad, r.y + r.h - rad);
      return {x,y};
    }
    function makeBlobAt(x,y,rad,spawnId=null){
      const s = rand(CFG.speedMin, CFG.speedMax);
      const a = rand(0, Math.PI*2);
      return { r:rad, x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, c: pick(CFG.colors), spawnId };
    }
    function ensureBlobs(){
      if (state.spawns.length){
        // доселяем недостающее по каждой секции
        const have = new Map();
        for (const b of state.blobs) if (b.spawnId) have.set(b.spawnId, (have.get(b.spawnId)||0)+1);
        for (const sp of state.spawns){
          const need = Math.max(0, sp.count - (have.get(sp.id)||0));
          for (let i=0;i<need;i++){
            const r = CFG.radii[(state.blobs.length + i) % CFG.radii.length];
            let placed = false, tries=50;
            while (tries-- > 0 && !placed){
              const p = placeInsideRect(sp.rect, r);
              if (!overlapsNoFly(p.x,p.y,r)){
                state.blobs.push(makeBlobAt(p.x,p.y,r, sp.id));
                placed = true;
              }
            }
            if (!placed){
              // крайний случай: глобально, но вне no-fly
              let x = rand(CFG.margin + r, state.worldW - CFG.margin - r);
              let y = rand(CFG.margin + r, state.worldH - CFG.margin - r);
              let t=50; while (overlapsNoFly(x,y,r) && --t>0){
                x = rand(CFG.margin + r, state.worldW - CFG.margin - r);
                y = rand(CFG.margin + r, state.worldH - CFG.margin - r);
              }
              state.blobs.push(makeBlobAt(x,y,r, sp.id));
            }
          }
        }
        return;
      }
      // фолбэк без spawn-зон
      while (state.blobs.length < CFG.count){
        const r = CFG.radii[state.blobs.length % CFG.radii.length];
        let x = rand(CFG.margin + r, state.worldW - CFG.margin - r);
        let y = rand(CFG.margin + r, state.worldH - CFG.margin - r);
        let t=40; while (overlapsNoFly(x,y,r) && --t>0){
          x = rand(CFG.margin + r, state.worldW - CFG.margin - r);
          y = rand(CFG.margin + r, state.worldH - CFG.margin - r);
        }
        state.blobs.push(makeBlobAt(x,y,r));
      }
      while (state.blobs.length > CFG.count) state.blobs.pop();
    }

    // --- update/paint ---
    function update(dt){
      const M = CFG.margin;
      for (const b of state.blobs){
        const ang = Math.atan2(b.vy, b.vx) + (Math.random()*2-1)*CFG.jitter*dt;
        const spd = Math.hypot(b.vx, b.vy);
        const tgt = clamp(spd, CFG.speedMin, CFG.speedMax);
        b.vx = Math.cos(ang)*tgt;
        b.vy = Math.sin(ang)*tgt;

        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.x < M + b.r){ b.x = M + b.r; b.vx = Math.abs(b.vx); }
        if (b.x > state.worldW - M - b.r){ b.x = state.worldW - M - b.r; b.vx = -Math.abs(b.vx); }
        if (b.y < M + b.r){ b.y = M + b.r; b.vy = Math.abs(b.vy); }
        if (b.y > state.worldH - M - b.r){ b.y = state.worldH - M - b.r; b.vy = -Math.abs(b.vy); }

        for (const rc of state.rects){
          if (b.y + b.r < rc.y - 1) continue;
          if (b.y - b.r > rc.y + rc.h + 1) continue;
          const hit = circleRectOverlap(b, b.r, rc);
          if (hit.hit) steerAway(b, hit);
          else {
            const ex = { x: rc.x - b.r, y: rc.y - b.r, w: rc.w + 2*b.r, h: rc.h + 2*b.r };
            if (b.x > ex.x && b.x < ex.x + ex.w && b.y > ex.y && b.y < ex.y + ex.h){
              const cx = clamp(b.x, rc.x, rc.x + rc.w);
              const cy = clamp(b.y, rc.y, rc.y + rc.h);
              const dx = b.x - cx, dy = b.y - cy;
              const d = Math.hypot(dx, dy) + 0.0001;
              b.vx += (dx/d) * 20 * dt;
              b.vy += (dy/d) * 20 * dt;
            }
          }
        }
      }
    }

    function hexA(hex, a){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      const r = parseInt(m[1],16), g = parseInt(m[2],16), b = parseInt(m[3],16);
      return `rgba(${r},${g},${b},${a})`;
    }

function paint(){
  ctx.clearRect(0, 0, state.viewW, state.viewH);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  const want = CFG.blend || 'screen';
  ctx.globalCompositeOperation = want;
  if (ctx.globalCompositeOperation !== want) ctx.globalCompositeOperation = 'lighter';

  const top = state.scrollY = (window.scrollY || document.documentElement.scrollTop || 0);
  const bottom = top + state.viewH;

  const a = CFG.plateauAlpha ?? 0.32;
  const innerK = Math.max(0.06, Math.min(0.4, CFG.innerStop ?? 0.14));
  const edge = Math.max(0.8, Math.min(0.98, CFG.edgeStop ?? 0.94));

  for (const b of state.blobs){
    if (b.y + b.r < top || b.y - b.r > bottom) continue;

    const sy = b.y - top;

    // чуть “перо” за границу, чтобы не было видимого края
    const rOut = b.r * 1.06;
    const rIn  = rOut * innerK;

    if (CFG.blurPx > 0) ctx.filter = `blur(${CFG.blurPx}px)`;

    const g = ctx.createRadialGradient(b.x, sy, rIn, b.x, sy, rOut);
    g.addColorStop(0.00, hexA(b.c, a));         // ровная заливка
    g.addColorStop(0.55, hexA(b.c, a));         // держим плотность
    g.addColorStop(edge, hexA(b.c, a * 0.35));  // мягкий спад к краю
    g.addColorStop(1.00, hexA(b.c, 0.00));      // полное растворение

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(b.x, sy, rOut, 0, Math.PI*2);       // рисуем по rOut → перышко выходит за круг
    ctx.fill();

    if (CFG.blurPx > 0) ctx.filter = 'none';
  }

  ctx.globalCompositeOperation = 'source-over';
}



    let last=0;
    function loop(ts){
      requestAnimationFrame(loop);
      const dt = last ? Math.min(0.05, (ts-last)/1000) : 0; last = ts;
      update(dt); paint();
    }

    // --- API + observers ---
    const API = {
      extraNoFly: [],
      setNoFly(arr){ API.extraNoFly = Array.isArray(arr) ? arr : []; collect(); ensureBlobs(); },
      refresh(){ resize(); collect(); ensureBlobs(); }
    };
    window.BallsBG = API;

    const deb=(fn,ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };

    const ro = new ResizeObserver(deb(() => { resize(); collect(); ensureBlobs(); }, 60));
    ro.observe(document.documentElement);
    window.addEventListener('resize', deb(()=>{ resize(); collect(); ensureBlobs(); }, 80), { passive:true });

    const mo = new MutationObserver(deb((muts)=>{
      let need=false, needTopUp=false;
      for (const m of muts){
        if (m.type==='attributes'){
          if (['data-spawn','data-spwn','data-nofly','data-no-fly','class','style','hidden'].includes(m.attributeName)){
            need = true; needTopUp = needTopUp || m.attributeName.startsWith('data-sp');
          }
        } else if (m.type==='childList'){
          if ([...m.addedNodes].some(n=>n.nodeType===1 && (n.hasAttribute?.('data-spawn') || n.hasAttribute?.('data-spwn') || n.querySelector?.('[data-spawn],[data-spwn]')))) {
            need = true; needTopUp = true;
          }
          if ([...m.addedNodes, ...m.removedNodes].some(n=>n.nodeType===1 && (n.hasAttribute?.('data-nofly') || n.hasAttribute?.('data-no-fly') || n.querySelector?.('[data-nofly],[data-no-fly]')))) {
            need = true;
          }
        }
      }
      if (need){ collect(); if (needTopUp) ensureBlobs(); }
    }, 80));
    mo.observe(document.body, { attributes:true, subtree:true, childList:true, attributeFilter:['class','style','hidden','data-spawn','data-spwn','data-nofly','data-no-fly'] });

    // --- warm start: три прохода, чтобы дождаться лэйзи-ресурсов и корректно расширить мир ---
    function warm(){
      resize(); collect(); ensureBlobs();
      requestAnimationFrame(()=>{ resize(); collect(); ensureBlobs(); });
      setTimeout(()=>{ resize(); collect(); ensureBlobs(); }, 220);
    }
    if (document.readyState === 'complete') warm();
    else window.addEventListener('load', warm, { once:true });

    paint();
    if (!matchMedia('(prefers-reduced-motion: reduce)').matches) requestAnimationFrame(loop);
  })();
  </script>



  {% if request.resolver_match.url_name == 'home' %}
  <header class="ls-header ls-header--static">
    <div class="ls-header__inner">

      <a href="#!" class="pdf-button-header js-rq-open" id="pdfBtn">
        <svg width="29" height="33">
          <use xlink:href="{% static 'images/icons.svg' %}#icon-pdf"></use>
        </svg>
        Запросить каталог PDF
      </a>

      <a class="ls-logo header-static" href="{% url 'home' %}">
        <img src="{% static 'images/logo.png' %}" alt="LS Illumination">
        <div class="logo-brand-container">
          <span class="ls-logo__brand">LS ILLUMINATION</span>
          <span class="ls-logo__ru">СВЕТОВЫЕ РЕШЕНИЯ</span>
        </div>
      </a>

      <a href="#!" class="btn-link js-rq-open">
        <div class="btn-glow">
          <div class="btn-border"></div>
          <div class="btn-text">
            <p>Оставить заявку</p>
          </div>
        </div>
      </a>
    </div>

    <nav class="ls-nav">
      <a href="#!" class="ls-nav__btn js-pf-open">Портфолио</a>
      <a href="#!" class="js-ct-open">Контакты</a>
      <a href="{% url 'about' %}">О нас</a>
    </nav>
  </header>
  {% endif %}



  <header class="ls-header ls-header--fixed">
    <div class="ls-header__inner">

      <!-- ЛЕВО: бургер (мобилка) -->
      <button class="hdr-icon hdr-burger" id="hdrMenu" aria-label="Открыть меню">
        <svg width="32" height="24" viewBox="0 0 32 24">
          <use xlink:href="{% static 'images/icons.svg' %}#icon-burger"></use>
        </svg>
      </button>

      <a class="ls-logo" href="{% url 'home' %}">
        <img src="{% static 'images/logo.png' %}" alt="LS Illumination">
        <span class="ls-logo__brand">LS ILLUMINATION</span>
        <i class="ls-logo__sep"></i>
        <span class="ls-logo__ru">СВЕТОВЫЕ РЕШЕНИЯ</span>
      </a>

      <nav class="ls-nav">
        <a href="#!" class="ls-nav__btn js-pf-open">Портфолио</a>
        <a href="#!" class="js-ct-open">Контакты</a>
        <a href="{% url 'about' %}">О нас</a>
      </nav>

      <!-- <a class="glow-btn" href="#" id="rqOpen">
        <div class="glass-btn">
          <p>Оставить заявку</p>
        </div>
      </a> -->


      <a href="#!" class="btn-link js-rq-open">
        <div class="btn-glow">
          <div class="btn-border"></div>
          <div class="btn-text">
            <p>Оставить заявку</p>
          </div>
        </div>
      </a>


      <!-- ПРАВО: конверт (мобилка) -->
      <button class="hdr-icon hdr-mail" id="hdrMail" aria-label="Открыть контакты">
        <svg width="28" height="26" viewBox="0 0 28 26">
          <use xlink:href="{% static 'images/icons.svg' %}#icon-mail"></use>
        </svg>
      </button>
    </div>
  </header>



  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const fixedHeader = document.querySelector('.ls-header--fixed');
      const isHome = document.body.classList.contains('is-home');

      if (isHome) {
        const reveal = () => {
          if (window.scrollY > 1000) fixedHeader.classList.add('show');
          else fixedHeader.classList.remove('show');
        };
        window.addEventListener('scroll', reveal, { passive: true });
        reveal();
      } else {
        fixedHeader.classList.add('show');
      }
    });
  </script>





  <script>
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('hdrMenu')?.addEventListener('click', e => {
        e.preventDefault(); document.getElementById('pfOpen')?.click();
      });
      document.getElementById('hdrMail')?.addEventListener('click', e => {
        e.preventDefault(); document.getElementById('ctOpen')?.click();
      });
    });
  </script>

  <div class="pf-underlay" id="pfUnderlay"></div>
  <section class="pf-panel" id="pfPanel" role="dialog" aria-modal="true">
    <div class="pf-panel__glass">
      <div class="pf-grid">
        {% for row in categories|chunk_categories %}
        <div class="pf-grid pf-grid--{{ row|length }}">
          {% for cat in row %}
          <a class="pf-card" href="{% url 'portfolio' slug=cat.slug %}">
            {% if cat.icon.url %}<img src="{{ cat.icon.url }}" alt="{{ cat.name }}">{% endif %}
            <span>{{ cat.name }}</span>
          </a>
          {% endfor %}
        </div>
        {% endfor %}
      </div>

    </div>
  </section>





  {% block content %}

  {% endblock content %}


  <footer class="ls-footer">
    <div class="footer-fade footer-fade--top"></div>


    <a href="">Пользовательское соглашение</a>
    <a href="">Политика конфиденциальности</a>
    <a class="footer-comp-name" href="">© LS illumination, 2009-2025</a>
    <a class="by" href="">
      <p>by</p>
      <span class="by-span">
        <svg width="21" height="18" viewBox="0 0 21 18">
          <use xlink:href="{% static 'images/icons.svg' %}#icon-diamond"></use>
        </svg>
      </span>
    </a>

    <div id="galaxy-root" class="galaxy-root" aria-hidden="true"></div>
  </footer>



  <script type="module">
    import * as OGL from 'https://cdn.skypack.dev/ogl';
    const { Renderer, Program, Mesh, Triangle, Color, Vec3 } = OGL;
    const V3 = Color || Vec3; // в одних версиях есть Color, в других только Vec3

    const vertexShader = `
  attribute vec2 uv;
  attribute vec2 position;

  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = vec4(position, 0, 1);
  }
  `;


    const fragmentShader = `
  precision highp float;

  uniform float uTime;
  uniform vec3 uResolution;
  uniform vec2 uFocal;
  uniform vec2 uRotation;
  uniform float uStarSpeed;
  uniform float uDensity;
  uniform float uHueShift;
  uniform float uSpeed;
  uniform vec2 uMouse;
  uniform float uGlowIntensity;
  uniform float uSaturation;
  uniform bool uMouseRepulsion;
  uniform float uTwinkleIntensity;
  uniform float uRotationSpeed;
  uniform float uRepulsionStrength;
  uniform float uMouseActiveFactor;
  uniform float uAutoCenterRepulsion;
  uniform bool uTransparent;

  varying vec2 vUv;

  #define NUM_LAYER 4.0
  #define STAR_COLOR_CUTOFF 0.2
  #define MAT45 mat2(0.7071, -0.7071, 0.7071, 0.7071)
  #define PERIOD 3.0

  float Hash21(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
  }

  float tri(float x) {
    return abs(fract(x) * 2.0 - 1.0);
  }

  float tris(float x) {
    float t = fract(x);
    return 1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0));
  }

  float trisn(float x) {
    float t = fract(x);
    return 2.0 * (1.0 - smoothstep(0.0, 1.0, abs(2.0 * t - 1.0))) - 1.0;
  }

  vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }

  float Star(vec2 uv, float flare) {
    float d = length(uv);
    float m = (0.05 * uGlowIntensity) / d;
    float rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
    m += rays * flare * uGlowIntensity;
    uv *= MAT45;
    rays = smoothstep(0.0, 1.0, 1.0 - abs(uv.x * uv.y * 1000.0));
    m += rays * 0.3 * flare * uGlowIntensity;
    m *= smoothstep(1.0, 0.2, d);
    return m;
  }

  vec3 StarLayer(vec2 uv) {
    vec3 col = vec3(0.0);

    vec2 gv = fract(uv) - 0.5; 
    vec2 id = floor(uv);

    for (int y = -1; y <= 1; y++) {
      for (int x = -1; x <= 1; x++) {
        vec2 offset = vec2(float(x), float(y));
        vec2 si = id + vec2(float(x), float(y));
        float seed = Hash21(si);
        float size = fract(seed * 345.32);
        float glossLocal = tri(uStarSpeed / (PERIOD * seed + 1.0));
        float flareSize = smoothstep(0.9, 1.0, size) * glossLocal;

        float red = smoothstep(STAR_COLOR_CUTOFF, 1.0, Hash21(si + 1.0)) + STAR_COLOR_CUTOFF;
        float blu = smoothstep(STAR_COLOR_CUTOFF, 1.0, Hash21(si + 3.0)) + STAR_COLOR_CUTOFF;
        float grn = min(red, blu) * seed;
        vec3 base = vec3(red, grn, blu);
        
        float hue = atan(base.g - base.r, base.b - base.r) / (2.0 * 3.14159) + 0.5;
        hue = fract(hue + uHueShift / 360.0);
        float sat = length(base - vec3(dot(base, vec3(0.299, 0.587, 0.114)))) * uSaturation;
        float val = max(max(base.r, base.g), base.b);
        base = hsv2rgb(vec3(hue, sat, val));

        vec2 pad = vec2(tris(seed * 34.0 + uTime * uSpeed / 10.0), tris(seed * 38.0 + uTime * uSpeed / 30.0)) - 0.5;

        float star = Star(gv - offset - pad, flareSize);
        vec3 color = base;

        float twinkle = trisn(uTime * uSpeed + seed * 6.2831) * 0.5 + 1.0;
        twinkle = mix(1.0, twinkle, uTwinkleIntensity);
        star *= twinkle;
        
        col += star * size * color;
      }
    }

    return col;
  }

  void main() {
    vec2 focalPx = uFocal * uResolution.xy;
    vec2 uv = (vUv * uResolution.xy - focalPx) / uResolution.y;

    vec2 mouseNorm = uMouse - vec2(0.5);
    
    if (uAutoCenterRepulsion > 0.0) {
      vec2 centerUV = vec2(0.0, 0.0);
      float centerDist = length(uv - centerUV);
      vec2 repulsion = normalize(uv - centerUV) * (uAutoCenterRepulsion / (centerDist + 0.1));
      uv += repulsion * 0.05;
    } else if (uMouseRepulsion) {
      vec2 mousePosUV = (uMouse * uResolution.xy - focalPx) / uResolution.y;
      float mouseDist = length(uv - mousePosUV);
      vec2 repulsion = normalize(uv - mousePosUV) * (uRepulsionStrength / (mouseDist + 0.1));
      uv += repulsion * 0.05 * uMouseActiveFactor;
    } else {
      vec2 mouseOffset = mouseNorm * 0.1 * uMouseActiveFactor;
      uv += mouseOffset;
    }

    float autoRotAngle = uTime * uRotationSpeed;
    mat2 autoRot = mat2(cos(autoRotAngle), -sin(autoRotAngle), sin(autoRotAngle), cos(autoRotAngle));
    uv = autoRot * uv;

    uv = mat2(uRotation.x, -uRotation.y, uRotation.y, uRotation.x) * uv;

    vec3 col = vec3(0.0);

    for (float i = 0.0; i < 1.0; i += 1.0 / NUM_LAYER) {
      float depth = fract(i + uStarSpeed * uSpeed);
      float scale = mix(20.0 * uDensity, 0.5 * uDensity, depth);
      float fade = depth * smoothstep(1.0, 0.9, depth);
      col += StarLayer(uv * scale + i * 453.32) * fade;
    }

    if (uTransparent) {
      float alpha = length(col);
      alpha = smoothstep(0.0, 0.3, alpha);
      alpha = min(alpha, 1.0);
      gl_FragColor = vec4(col, alpha);
    } else {
      gl_FragColor = vec4(col, 1.0);
    }
  }
  `;

    function mountGalaxy(container, o = {}) {
      const d = Object.assign({
        focal: [0.5, 0.5],
        rotation: [1.0, 0.0],
        starSpeed: 0.5,
        density: 1,
        hueShift: 140,
        disableAnimation: false,
        speed: 1.0,
        mouseInteraction: true,
        glowIntensity: 0.3,
        saturation: 0.0,
        mouseRepulsion: true,
        repulsionStrength: 2,
        twinkleIntensity: 0.3,
        rotationSpeed: 0.1,
        autoCenterRepulsion: 0,
        transparent: true
      }, o);

      const renderer = new Renderer({ alpha: d.transparent, premultipliedAlpha: false });
      const gl = renderer.gl;
      if (d.transparent) {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA,
          gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0, 0, 0, 0);
      }
      else gl.clearColor(0, 0, 0, 1);

      container.appendChild(gl.canvas);

      const geometry = new Triangle(gl);
      const program = new Program(gl, {
        vertex: vertexShader,
        fragment: fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          uResolution: { value: new V3(1, 1, 1) },
          uFocal: { value: new Float32Array(d.focal) },
          uRotation: { value: new Float32Array(d.rotation) },
          uStarSpeed: { value: d.starSpeed },
          uDensity: { value: d.density },
          uHueShift: { value: d.hueShift },
          uSpeed: { value: d.speed },
          uMouse: { value: new Float32Array([0.5, 0.5]) },
          uGlowIntensity: { value: d.glowIntensity },
          uSaturation: { value: d.saturation },
          uMouseRepulsion: { value: d.mouseRepulsion },
          uTwinkleIntensity: { value: d.twinkleIntensity },
          uRotationSpeed: { value: d.rotationSpeed },
          uRepulsionStrength: { value: d.repulsionStrength },
          uMouseActiveFactor: { value: 0.0 },
          uAutoCenterRepulsion: { value: d.autoCenterRepulsion },
          uTransparent: { value: d.transparent }
        }
      });
      const mesh = new Mesh(gl, { geometry, program });

      const target = { x: 0.5, y: 0.5, a: 0.0 };
      const smooth = { x: 0.5, y: 0.5, a: 0.0 };

      function resize() {
        const r = container.getBoundingClientRect();
        renderer.setSize(r.width, r.height);       // без *devicePixelRatio
        program.uniforms.uResolution.value = new V3(
          gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height
        );
      }
      const ro = new ResizeObserver(resize); ro.observe(container);
      window.addEventListener('resize', resize, { passive: true });
      resize();

      function onMove(e) {
        const r = container.getBoundingClientRect();
        target.x = (e.clientX - r.left) / r.width;
        target.y = 1 - (e.clientY - r.top) / r.height;
        target.a = 1.0;
      }
      function onLeave() { target.a = 0.0; }
      if (d.mouseInteraction) {
        window.addEventListener('pointermove', onMove, { passive: true });
        window.addEventListener('pointerleave', onLeave, { passive: true });
      }

      let raf;
      function tick(t) {
        raf = requestAnimationFrame(tick);
        if (!d.disableAnimation) {
          program.uniforms.uTime.value = t * 0.001;
          program.uniforms.uStarSpeed.value = (t * 0.001 * d.starSpeed) / 10.0;
        }
        const k = 0.05;
        smooth.x += (target.x - smooth.x) * k;
        smooth.y += (target.y - smooth.y) * k;
        smooth.a += (target.a - smooth.a) * k;
        program.uniforms.uMouse.value[0] = smooth.x;
        program.uniforms.uMouse.value[1] = smooth.y;
        program.uniforms.uMouseActiveFactor.value = smooth.a;
        renderer.render({ scene: mesh });
      }
      tick();

      return () => {
        cancelAnimationFrame(raf);
        ro.disconnect();
        window.removeEventListener('resize', resize);
        if (d.mouseInteraction) { container.removeEventListener('mousemove', onMove); container.removeEventListener('mouseleave', onLeave); }
        container.contains(gl.canvas) && container.removeChild(gl.canvas);
        gl.getExtension('WEBGL_lose_context')?.loseContext();
      };
    }

    const root = document.getElementById('galaxy-root');
    if (root) mountGalaxy(root, {
      mouseRepulsion: true,
      mouseInteraction: true,
      density: 0.7,
      glowIntensity: 0.8,
      saturation: 1.0,
      hueShift: 140,
      twinkleIntensity: 0.3,
      rotationSpeed: 0.3,
      repulsionStrength: 4,
      starSpeed: 0.9,
      speed: 1.4,
      transparent: true
    });
  </script>



  <div class="cookie-banner" id="cookieBanner" hidden>
    <div class="cookie-banner__wrap">
      <h3 class="cookie-desktop-h">Мы используем файлы cookie</h3>
      <p class="cookie-desktop-p">
        Этот сайт применяет cookie-файлы и аналогичные технологии, чтобы обеспечить корректную работу,
        улучшить удобство использования, анализировать трафик и предлагать персонализированный контент.
        Подробнее — см. нашу <a href="/cookie-policy/" target="_blank">Политику использования файлов cookie</a>.
      </p>
      <p class="cookie-mobile-p">Пользуясь сайтом, вы соглашаетесь с использованием <a href="/cookie-policy/"
          target="_blank">cookie и политикой конфиденциальности</a></p>
      <div class="cookie-banner__actions">
        <button class="cookie-btn cookie-btn--decline" id="cookieDecline">Отклонить</button>
        <button class="cookie-btn cookie-btn--accept" id="cookieAccept">Принять все</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const banner = document.getElementById('cookieBanner');
      const accept = document.getElementById('cookieAccept');
      const decline = document.getElementById('cookieDecline');

      if (!localStorage.getItem('cookieConsent')) {
        banner.hidden = false;
      }

      function setConsent(value) {
        localStorage.setItem('cookieConsent', value);
        banner.hidden = true;
      }

      accept.addEventListener('click', () => setConsent('accepted'));
      decline.addEventListener('click', () => setConsent('declined'));
    })();
  </script>





  <div class="rq-underlay" id="rqUnderlay" hidden></div>
  <section class="rq-modal" id="rqModal" role="dialog" aria-modal="true" aria-labelledby="rqTitle" hidden>
    <div class="rq-wrap">
      <div class="rq-card">
        <button class="rq-close" type="button" id="rqClose" aria-label="Закрыть">
          <svg width="22" height="22" viewBox="0 0 22 22">
            <use xlink:href="{% static 'images/icons.svg' %}#icon-close"></use>
          </svg>
        </button>
        <h2 class="rq-title" id="rqTitle">Напишите нам</h2>

        <form class="rq-form" method="post" action="{% url 'req_submit' %}">
          {% csrf_token %}
          <input type="hidden" name="hp" value="">
          <input type="hidden" name="ts" value="{{ now_ts|default:0 }}">

          <div class="rq-row rq-row--3">
            <label class="rq-field">
              <span>Ваше имя*</span>
              <input type="text" name="name" id="rqName" required>
            </label>
            <label class="rq-field">
              <span>Телефон*</span>
              <input type="tel" name="phone" inputmode="tel" placeholder="+7" id="rqPhone" required>
            </label>
            <label class="rq-field">
              <span>E-mail</span>
              <input type="email" name="email">
            </label>
          </div>

          <label class="rq-field rq-field--area">
            <span>Сообщение</span>
            <textarea name="message" rows="4"></textarea>
          </label>


          <label class="rq-field rq-field--file">
            <input type="file" name="file" id="rqFile" hidden>
            <span class="rq-file-label" id="rqFileLabel" onclick="document.getElementById('rqFile').click()">
              <img src="{% static 'images/clip.png' %}" alt="Прикрепить файл" class="rq-file-icon">
              Прикрепить файл
            </span>
          </label>

          <script>
            document.getElementById('rqFile').addEventListener('change', function () {
              const label = document.getElementById('rqFileLabel');
              if (this.files.length > 0) {
                label.innerHTML = '<img src="{% static "images/clip.png" %}" class="rq-file-icon">' + this.files[0].name;
              } else {
                label.innerHTML = '<img src="{% static "images/clip.png" %}" class="rq-file-icon"> Прикрепить файл';
              }
            });
          </script>


          <div class="rq-bottom">
            <label class="rq-check">
              <input type="checkbox" required>
              <i></i>
              <span>Нажимая кнопку отправить, вы соглашаетесь с политикой обработки персональных данных</span>
            </label>
            <button class="rq-submit" type="submit">Отправить</button>
          </div>
        </form>
      </div>
    </div>
  </section>


  <script>
    (() => {
      const nameInput = document.getElementById('rqName');
      const phoneInput = document.getElementById('rqPhone');

      nameInput.addEventListener('input', () => {
        nameInput.value = nameInput.value.replace(/[^a-zA-Zа-яА-ЯёЁ\s-]/g, '');
      });

      phoneInput.addEventListener('input', () => {
        let v = phoneInput.value.replace(/\D/g, '');
        if (!v) { phoneInput.value = ''; return; }

        if (v[0] === '7') {
          v = '7' + v.slice(1);
          phoneInput.value = format(v, true);
        } else if (v[0] === '8') {
          phoneInput.value = format(v, false);
        } else {
          phoneInput.value = format(v, true);
        }
      });

      function format(d, plus) {
        const p = d.padEnd(11, '_').slice(0, 11);
        const part1 = p.slice(1, 4);
        const part2 = p.slice(4, 7);
        const part3 = p.slice(7, 9);
        const part4 = p.slice(9, 11);

        return (plus ? '+7' : '8') +
          ` (${part1}) ${part2}-${part3}-${part4}`.replace(/[_-]+$/, '');
      }
    })();
  </script>


  <script>
    (function () {
      var ts = document.querySelector('form.rq-form input[name="ts"]');
      if (ts && (!ts.value || ts.value === "0")) ts.value = Math.floor(Date.now() / 1000);
    })();
  </script>

  <section class="rq-modal" id="ctModal" role="dialog" aria-modal="true" aria-labelledby="ctTitle" hidden>
    <div class="rq-wrap">
      <div class="rq-card contacts-modal">
        <button class="rq-close" type="button" id="ctClose" aria-label="Закрыть">
          <svg width="22" height="22" viewBox="0 0 22 22">
            <use xlink:href="{% static 'images/icons.svg' %}#icon-close"></use>
          </svg>
        </button>
        <h2 class="rq-title" id="ctTitle">Контакты</h2>

        <div class="ct-grid">
          <div class="ct-col">
            <div class="ct-item">
              <span class="ct-label">Телефон</span>
              <div class="ct-val">+7 (812) 642-03-65</div>
            </div>
            <div class="ct-item">
              <span class="ct-label">Адрес</span>
              <div class="ct-val">г. Санкт-Петербург,<br>улица Ломоносова, 28</div>
            </div>
            <div class="ct-item">
              <span class="ct-label">E-mail*</span>
              <div class="ct-val"><a href="mailto:info@multidekor.ru">info@multidekor.ru</a></div>
            </div>
          </div>

          <div class="ct-col">
            <div class="ct-item">
              <span class="ct-label">Время работы:</span>
              <div class="ct-val">
                Пн–Пт<br>с 10:00 до 18:00
              </div>
            </div>
            <div class="ct-item">
              <div class="ct-val" style="margin-top:16px">
                Сб–Вс<br>Выходные дни
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>



  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const pfPanel = document.getElementById('pfPanel');
      const pfUnder = document.getElementById('pfUnderlay');
      const rqModal = document.getElementById('rqModal');
      const rqUnder = document.getElementById('rqUnderlay');
      const ctModal = document.getElementById('ctModal');

      const pfShow = () => {
        pfUnder.classList.add('show');
        pfPanel.getBoundingClientRect();
        pfPanel.classList.add('show');
        document.documentElement.classList.add('rq-lock');
      };

      const pfHide = () => {
        pfPanel.classList.remove('show');
        pfUnder.classList.remove('show');
        document.documentElement.classList.remove('rq-lock');
      };


      const rqShow = () => { rqUnder.hidden = false; rqModal.hidden = false; rqModal.getBoundingClientRect(); rqUnder.classList.add('show'); rqModal.classList.add('show'); document.documentElement.classList.add('rq-lock'); };
      const rqHide = () => { rqModal.classList.remove('show'); rqUnder.classList.remove('show'); rqModal.addEventListener('transitionend', () => { rqModal.hidden = true; rqUnder.hidden = true; }, { once: true }); document.documentElement.classList.remove('rq-lock'); };

      const ctShow = () => { rqUnder.hidden = false; ctModal.hidden = false; ctModal.getBoundingClientRect(); rqUnder.classList.add('show'); ctModal.classList.add('show'); document.documentElement.classList.add('rq-lock'); };
      const ctHide = () => { ctModal.classList.remove('show'); rqUnder.classList.remove('show'); ctModal.addEventListener('transitionend', () => { ctModal.hidden = true; rqUnder.hidden = true; }, { once: true }); document.documentElement.classList.remove('rq-lock'); };

      document.querySelectorAll('.js-pf-open').forEach(el => el.addEventListener('click', e => {
        e.preventDefault(); pfPanel.classList.contains('show') ? pfHide() : pfShow();
      }));

      document.querySelectorAll('.js-rq-open').forEach(el => el.addEventListener('click', e => {
        e.preventDefault(); rqShow();
      }));

      document.getElementById('rqClose')?.addEventListener('click', rqHide);
      rqUnder?.addEventListener('click', () => {
        if (ctModal.classList.contains('show')) ctHide();
        if (rqModal.classList.contains('show')) rqHide();
      });

      document.querySelectorAll('.js-ct-open').forEach(el => el.addEventListener('click', e => {
        e.preventDefault(); ctShow();
      }));
      document.getElementById('ctClose')?.addEventListener('click', ctHide);

      // бургер/конверт в обоих хедерах
      document.querySelectorAll('.js-burger').forEach(b => b.addEventListener('click', e => { e.preventDefault(); pfPanel.classList.contains('show') ? pfHide() : pfShow(); }));
      document.querySelectorAll('.js-mail').forEach(b => b.addEventListener('click', e => { e.preventDefault(); ctShow(); }));

      // защита от клика внутри карточек модалок
      document.querySelectorAll('.rq-modal .rq-card').forEach(card => {
        card.addEventListener('click', e => e.stopPropagation());
        card.parentElement?.parentElement?.addEventListener('click', e => {
          const sec = e.currentTarget;
          if (sec.id === 'rqModal') rqHide();
          if (sec.id === 'ctModal') ctHide();
        });
      });
    });
  </script>




  <!-- Скрипт шариков -->
  <!-- <script>
    (() => {
      const cv = document.getElementById('bgCanvasBase');
      if (!cv) return;

      const ctx = cv.getContext('2d');
      const OFF = document.createElement('canvas');
      const OX = OFF.getContext('2d');
      let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const CFG = {
        count: 3,              // сколько шаров
        speed: 80,             // px/s
        jitter: 0.7,           // «блуждание»
        colors: ['#ff2bd6', '#8b5cf6', '#2bd7ff'],
        radii: [320, 260, 380],
        soft: [0.60, 0.55, 0.65]
      };

      const prefersReduced = matchMedia('(prefers-reduced-motion: reduce)').matches;

      function resize() {
        const w = Math.round(innerWidth * DPR);
        const h = Math.round(innerHeight * DPR);
        if (OFF.width !== w || OFF.height !== h) {
          OFF.width = w; OFF.height = h;
          OX.setTransform(DPR, 0, 0, DPR, 0, 0); // рисуем в CSS-пикселях
        }
        if (cv.width !== w || cv.height !== h) {
          cv.width = w; cv.height = h;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
      }

      const blobs = [];
      function makeBlob(i) {
        return {
          i, dir: Math.random() * Math.PI * 2,
          x: Math.random() * innerWidth,
          y: Math.random() * innerHeight,
          get r() { return CFG.radii[i] ?? 300; },
          get s() { return CFG.soft[i] ?? 0.6; },
          get c() { return CFG.colors[i] ?? '#fff'; }
        };
      }
      function ensureBlobs() {
        while (blobs.length < CFG.count) blobs.push(makeBlob(blobs.length));
        while (blobs.length > CFG.count) blobs.pop();
      }

      const hex2rgb = (hex) => {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 255, g: 255, b: 255 };
      };
      const rgba = (r, g, b, a) => `rgba(${r},${g},${b},${a})`;

      function update(dt) {
        const spd = CFG.speed, jit = CFG.jitter, M = 200;
        for (const b of blobs) {
          b.dir += (Math.random() * 2 - 1) * jit * dt;
          b.x += Math.cos(b.dir) * spd * dt;
          b.y += Math.sin(b.dir) * spd * dt;
          if (b.x < -M) b.x = innerWidth + M;
          if (b.x > innerWidth + M) b.x = -M;
          if (b.y < -M) b.y = innerHeight + M;
          if (b.y > innerHeight + M) b.y = -M;
        }
      }

      function paint() {
        OX.clearRect(0, 0, innerWidth, innerHeight);
        OX.globalCompositeOperation = 'lighter';
        for (const b of blobs) {
          const { r, g, b: bb } = hex2rgb(b.c);
          const mid = 0.15 + 0.75 * Math.max(0, Math.min(1, b.s));
          const grd = OX.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
          grd.addColorStop(0.0, rgba(r, g, bb, 0.60));
          grd.addColorStop(mid, rgba(r, g, bb, 0.25));
          grd.addColorStop(1.0, rgba(r, g, bb, 0.00));
          OX.fillStyle = grd;
          OX.beginPath(); OX.arc(b.x, b.y, b.r, 0, Math.PI * 2); OX.fill();
        }
        OX.globalCompositeOperation = 'source-over';
        ctx.clearRect(0, 0, cv.width, cv.height);
        ctx.drawImage(OFF, 0, 0);
      }

      let raf = null, last = 0;
      function loop(ts) {
        const dt = last ? (ts - last) / 1000 : 0; last = ts;
        update(dt); paint();
        raf = requestAnimationFrame(loop);
      }
      function start() { if (prefersReduced) return; DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); resize(); ensureBlobs(); paint(); if (!raf) raf = requestAnimationFrame(loop); }
      function stop() { if (raf) { cancelAnimationFrame(raf); raf = null; } }

      addEventListener('resize', () => { DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); resize(); paint(); }, { passive: true });
      document.addEventListener('visibilitychange', () => document.hidden ? stop() : start());

      start();
    })();
  </script> -->






  <!-- Lenis -->
  <script src="https://unpkg.com/lenis@1.3.11/dist/lenis.min.js"></script>
  <script>
    if (!matchMedia('(prefers-reduced-motion: reduce)').matches) {
      let useLenis = false;

      window.addEventListener("wheel", function detectDevice(e) {
        if (Math.abs(e.deltaY) >= 50) {
          useLenis = true;
        } else {
          useLenis = false;
        }

        if (useLenis && !window.lenis) {
          const lenis = new Lenis({
            duration: 1.3,
            smoothWheel: true,
            normalizeWheel: true
          });

          function raf(t) {
            lenis.raf(t);
            requestAnimationFrame(raf);
          }
          requestAnimationFrame(raf);
          window.lenis = lenis;
        }
        window.removeEventListener("wheel", detectDevice);
      }, { passive: true });
    }
  </script>









  <!-- Новый скрипт кнопок -->
  <script>
    (() => {
      const norm360 = v => ((v % 360) + 360) % 360;
      const angleTo = (el, x, y) => {
        const r = el.getBoundingClientRect();
        const cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let deg = Math.atan2(y - cy, x - cx) * 180 / Math.PI;
        if (deg < 0) deg += 360;
        return (deg + 90) % 360;
      };

      document.querySelectorAll('.btn-glow').forEach(btn => {
        let raf = 0, last = 0, vis = 0, target = 0, frozen = false;
        const link = btn.closest('.btn-link');

        function step(ts) {
          const dt = (ts - (last || ts)) / 1000; last = ts;
          const d = ((target - vis + 540) % 360) - 180;
          vis = norm360(vis + d * Math.min(1, dt * 12));
          const v = vis + 'deg';
          btn.style.setProperty('--base-angle', v);
          if (link) link.style.setProperty('--base-angle', v);
          if (!frozen) raf = requestAnimationFrame(step); else raf = 0;
        }

        btn.addEventListener('mouseenter', () => {
          frozen = true;
          if (raf) { cancelAnimationFrame(raf); raf = 0; }
        }, { passive: true });

        btn.addEventListener('mouseleave', () => {
          frozen = false;
          if (!raf) raf = requestAnimationFrame(step);
        }, { passive: true });

        btn.addEventListener('mousemove', e => {
          if (frozen) return;
          const r = btn.getBoundingClientRect();
          btn.style.setProperty('--x', (e.clientX - r.left) + 'px');
          btn.style.setProperty('--y', (e.clientY - r.top) + 'px');
          target = angleTo(btn, e.clientX, e.clientY);
          if (!raf) raf = requestAnimationFrame(step);
        }, { passive: true });

        raf = requestAnimationFrame(step);
      });
    })();
  </script>







  <!-- Старый скрипт кнопок -->
  <!-- <script>
    (() => {
      const btns = document.querySelectorAll('.glow-btn');
      if (!btns.length) return;

      const norm360 = v => ((v % 360) + 360) % 360;

      btns.forEach(btn => {
        let raf = 0, last = 0, vis = 0, target = 0, hover = false;

        function angleTo(el, x, y) {
          const r = el.getBoundingClientRect();
          const cx = r.left + r.width / 2, cy = r.top + r.height / 2;
          let deg = Math.atan2(y - cy, x - cx) * 180 / Math.PI;
          if (deg < 0) deg += 360;
          return (deg + 90) % 360;
        }

        function step(ts) {
          const dt = (ts - (last || ts)) / 1000; last = ts;
          const d = ((target - vis + 540) % 360) - 180;
          vis = norm360(vis + d * Math.min(1, dt * 12));
          btn.style.setProperty('--base-angle', vis + 'deg');
          if (hover) raf = requestAnimationFrame(step); else raf = 0;
        }

        function onMove(e) {
          target = angleTo(btn, e.clientX, e.clientY);
          if (!raf) raf = requestAnimationFrame(step);
        }

        btn.addEventListener('pointerenter', e => {
          hover = true;
          target = angleTo(btn, e.clientX, e.clientY);
          if (!raf) raf = requestAnimationFrame(step);
        }, { passive: true });

        btn.addEventListener('pointerleave', () => {
          hover = false;
        }, { passive: true });

        window.addEventListener('pointermove', e => { if (hover) onMove(e); }, { passive: true });
      });
    })();
  </script> -->





</body>


</html>